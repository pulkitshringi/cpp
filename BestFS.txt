# Best First Search

import heapq

def best_first_search(graph, start, goal):
    frontier = [(0, start)]  # Priority queue with initial cost and starting node
    explored = set()         # Set to keep track of explored nodes
    
    while frontier:
        # Pop the node with the lowest cost from the priority queue
        cost, current_node = heapq.heappop(frontier)
        
        if current_node == goal:
            return True  # Goal found
        
        explored.add(current_node)
        
        # Explore neighbors of the current node
        for neighbor, neighbor_cost in graph[current_node]:
            if neighbor not in explored:
                heapq.heappush(frontier, (neighbor_cost, neighbor))
    
    return False  # Goal not found
'''
State space tree: 
   A
  / \
 B   C
/     \
D       E
        \
         F
'''
# graph represented as an adjacency list
graph = {
    'A': [('B', 5), ('C', 7)],
    'B': [('D', 10)],
    'C': [('E', 3)],
    'D': [('F', 12)],
    'E': [('F', 2)],
    'F': []
}

start_node = 'A'
goal_node = 'F'

if best_first_search(graph, start_node, goal_node):
    print("Goal found!")
else:
    print("Goal not found.")
