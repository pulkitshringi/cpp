#A*

import heapq

def astar_search(start_state, goal_state, get_neighbors_fn, heuristic_fn):
    frontier = [(heuristic_fn(start_state), start_state)]  # Priority queue with heuristic value and state
    explored = set()  # Set to keep track of explored states
    parent_map = {}  # Dictionary to store parent nodes
    
    while frontier:
        _, current_state = heapq.heappop(frontier)  # Pop the state with the lowest heuristic value
        
        if current_state == goal_state:
            # Goal state reached, construct path
            path = []
            while current_state:
                path.append(current_state)
                current_state = parent_map.get(current_state)
            return path[::-1]  # Return path in reverse order
        
        explored.add(current_state)
        
        for neighbor in get_neighbors_fn(current_state):
            if neighbor not in explored:
                parent_map[neighbor] = current_state
                heapq.heappush(frontier, (heuristic_fn(neighbor), neighbor))
    
    return None  # Goal state not reachable

# Example heuristic function (Manhattan distance)
def manhattan_distance(state, goal_state):
    return abs(state[0] - goal_state[0]) + abs(state[1] - goal_state[1])

# Example function to get neighbors (up, down, left, right)
def get_neighbors(state):
    x, y = state
    neighbors = []
    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        new_x, new_y = x + dx, y + dy
        neighbors.append((new_x, new_y))
    return neighbors

# Example usage
start_state = (0, 0)
goal_state = (4, 4)
path = astar_search(start_state, goal_state, get_neighbors, lambda state: manhattan_distance(state, goal_state))
if path:
    print("Path found:", path)
else:
    print("Goal not reachable.")
